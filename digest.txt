Directory structure:
└── llm_mud/
    ├── __init__.py
    ├── cli.py
    ├── config.py
    ├── persist.py
    ├── core/
    │   ├── __init__.py
    │   ├── character.py
    │   ├── character_action.py
    │   ├── command_parser.py
    │   ├── player.py
    │   ├── room.py
    │   ├── world.py
    │   └── __pycache__/
    ├── gen/
    │   ├── __init__.py
    │   ├── create_world.py
    │   ├── room_gen.py
    │   ├── world_gen.py
    │   └── __pycache__/
    └── networking/
        ├── __init__.py
        ├── client.py
        ├── messages.py
        ├── server.py
        └── __pycache__/

================================================
File: __init__.py
================================================
"""
LLM-powered MUD game engine and server.
"""

__version__ = "0.1.0"


================================================
File: cli.py
================================================
import asyncio
import click
import sys
from pathlib import Path
from .core.world import World
from .networking.server import main as server_main
from .networking.client import main as client_main
from .gen import create_world as run_create_world

async def run_client():
    """Run the client."""
    await client_main()



async def run_server():
    """Run the server."""
    await server_main()


@click.group()
def main():
    """LLM-MUD: A text-based multiplayer game."""
    pass


@main.command()
def client():
    """Connect to a running MUD server."""
    asyncio.run(run_client())


@main.command()
def server():
    """Start the MUD server."""
    asyncio.run(run_server())


@main.command()
def dev():
    """Run both server and client for development."""

    async def run_dev():
        # Start server task
        server_task = asyncio.create_task(run_server())

        # Wait a bit for server to start
        click.echo("Starting server...")
        await asyncio.sleep(2)

        # Start client
        click.echo("Starting client...")
        client_task = asyncio.create_task(run_client())

        try:
            # Wait for either task to complete
            done, pending = await asyncio.wait(
                [server_task, client_task], return_when=asyncio.FIRST_COMPLETED
            )

            # Cancel remaining tasks
            for task in pending:
                task.cancel()
                try:
                    await task
                except asyncio.CancelledError:
                    pass
        except KeyboardInterrupt:
            click.echo("\nShutting down...")
            for task in [server_task, client_task]:
                if not task.done():
                    task.cancel()
                    try:
                        await task
                    except asyncio.CancelledError:
                        pass

    try:
        asyncio.run(run_dev())
    except KeyboardInterrupt:
        sys.exit(0)


@main.command()
@click.argument('theme')
def create_world(theme: str):
    """Create a new world with the specified theme."""
    try:
        asyncio.run(run_create_world(theme))
    except KeyboardInterrupt:
        sys.exit(0)


if __name__ == "__main__":
    main()


================================================
File: config.py
================================================
import os

# Model configuration for command parser
command_parser_model = "anthropic/claude-3.5-haiku"
#command_parser_model = "mistralai/mistral-nemo"
# command_parser_model = "deepseek/deepseek-chat"
# command_parser_model = "microsoft/phi-4" # DOESNT WORK
#creative_model = "gryphe/mythomax-l2-13b" # DOESNT SUPPORT TOOL
creative_model = "anthropic/claude-3.5-sonnet"


# API configuration
OPENROUTER_BASE_URL = "https://openrouter.ai/api/v1"
OPENROUTER_API_KEY = os.getenv("OPENROUTER_API_KEY")


================================================
File: persist.py
================================================
from pathlib import Path
from pydantic import BaseModel
from .core.world import World, WorldDescription
from .core.room import RoomDescription

class SerializedRoom(BaseModel):
    description: RoomDescription
    exits: dict[str, str]

class SerializedWorld(BaseModel):
    description: WorldDescription
    rooms: dict[str, SerializedRoom]
    starting_room_id: str

def load_world(filepath: str | Path) -> World:
    """
    Load world data from a JSON file and construct a World instance.
    
    Args:
        filepath: Path to the JSON world file
        
    Returns:
        A fully constructed World instance
    """
    world_data = SerializedWorld.model_validate_json(Path(filepath).read_text())
    world = World(description=world_data.description)
    
    # First create all rooms
    for room_id, room_data in world_data.rooms.items():
        world.create_room(
            room_id=room_id,
            description=room_data.description
        )
    
    # Then connect them
    for room_id, room_data in world_data.rooms.items():
        for direction, target_room_id in room_data.exits.items():
            world.connect_rooms(room_id, target_room_id, direction)
            
    world.set_starting_room(world_data.starting_room_id)
    
    return world

def save_world(world: World, filepath: str | Path) -> None:
    """Save world state to a JSON file"""
    serialized_rooms = {
        room_id: SerializedRoom(
            description=room.description,
            exits={direction: dest.id for direction, dest in room.exits.items()}
        )
        for room_id, room in world.rooms.items()
    }
    
    serialized_world = SerializedWorld(
        description=world.description,
        rooms=serialized_rooms,
        starting_room_id=world.starting_room_id
    )
    
    Path(filepath).write_text(serialized_world.model_dump_json(indent=2)) 

================================================
File: core/character.py
================================================
from .room import Room
import uuid


class Character:
    """Base class for all characters in the game."""

    def __init__(self, name: str, world: "World"):
        self.name = name
        self.id = str(uuid.uuid4())
        self.world: "World" = world

    async def tick(self) -> None:
        pass

    def get_current_room(self) -> Room:
        """Get the current room the character is in."""
        return self.world.get_character_room(self.id)


================================================
File: core/character_action.py
================================================
from pydantic import BaseModel, Field
from typing import Literal


class CharacterAction(BaseModel):
    """
    A character action.
    """

    action_type: Literal["move", "look"]
    direction: str | None = Field(
        description="The direction to move to, if applicable.", default=None
    )


================================================
File: core/command_parser.py
================================================
from dataclasses import dataclass
import os
from pydantic import BaseModel, Field
from pydantic_ai import Agent, RunContext
from pydantic_ai.models.openai import OpenAIModel

from ..config import command_parser_model, OPENROUTER_BASE_URL, OPENROUTER_API_KEY
from .character_action import CharacterAction
from devtools import debug

prompt = """
You are a command parser for a text-based adventure game.
You will parse the players command and return a command result object

Follow these instructions precisely. 
1. See if the command seems to be asking to move. 
    If so see if the direction is one of the available exits in the current location.
    If the direction is one of the available exits:
        - return an action with type "move" and the direction
        - use the correct direction name
        - Allow reasonable abbreviations, e.g. "n" for "north", "s" for "south", etc.
    If the direction is not valid:
        - return an error message explaining they can't go that way
2. See if the command is a look command. Only look if explicitly asked, e.g. "look around", or "describe the room", etc.
    If so return an action with type "look"
3. If none of the above, return an error message with a user friendly explanation
"""


class ParseResult(BaseModel):
    """Result of parsing a player's command input"""
    action: CharacterAction | None = Field(
        default=None, description="The parsed player action if command was valid"
    )
    error_msg: str | None = Field(
        default=None,
        description="Error message if command could not be parsed or was invalid",
    )


@dataclass
class Deps:
    world: "World"
    player: "Player"


model = OpenAIModel(
    command_parser_model,
    base_url=OPENROUTER_BASE_URL,
    api_key=OPENROUTER_API_KEY,
)

command_parser_agent = Agent(
    model=model,
    result_type=ParseResult,
    retries=2,
    system_prompt=prompt,
    model_settings={
        "temperature": 0.0,
    },
)


@command_parser_agent.system_prompt
async def system_prompt(ctx: RunContext[Deps]) -> str:
    world, player = ctx.deps.world, ctx.deps.player

    room = player.get_current_room()

    return f"""The following exits are available: {", ".join(room.exits.keys())}\n"""


async def parse(world: "World", player: "Player", command_input: str) -> ParseResult:
    """Parse and execute a player command.

    Args:
        world: The game world instance
        player: The player issuing the command
        command_input: The command string to parse

    Returns:
        ParseResult containing either a PlayerAction or error message
    """
    room = player.get_current_room()
    if command_input in room.exits:
        return ParseResult(
            action=CharacterAction(action_type="move", direction=command_input)
        )
    elif command_input in ("l", "look", "describe"):
        return ParseResult(action=CharacterAction(action_type="look"))
    else:
        result = await command_parser_agent.run(
            command_input, deps=Deps(world=world, player=player)
        )
        return result.data


================================================
File: core/player.py
================================================
from .character import Character
from asyncio import Queue
from ..networking.messages import MessageToPlayer, MessageToPlayerType
from .command_parser import parse
from .character_action import CharacterAction


class Player(Character):
    """Represents a player character in the game."""

    def __init__(self, name: str, world: "World"):
        super().__init__(name, world)
        self.queue: Queue[MessageToPlayer] = Queue()

    def __aiter__(self):
        return self

    async def __anext__(self):
        """Get the next message for the player."""
        return await self.queue.get()

    async def send_message(
        self, msg_type: MessageToPlayerType, message: str, msg_src: str | None = None
    ) -> None:
        """Send a message to the player."""
        await self.queue.put(
            MessageToPlayer(msg_type=msg_type, message=message, msg_src=msg_src)
        )

    async def process_command(self, command: str) -> None:
        """Process a command from the player."""
        parse_result = await parse(self.world, self, command)
        if parse_result.error_msg:
            await self.send_message("error", parse_result.error_msg)
            return

        action = parse_result.action
        await self.world.process_character_action(self, action)

    async def tick(self) -> None:
        pass
        # await self.send_message(PlayerMessageType.SERVER, "Tick")


================================================
File: core/room.py
================================================
from pydantic import BaseModel, Field

class RoomDescription(BaseModel):
    title: str = Field(
        description="The name/title of the room"
    )
    id: str = Field(
        description="Typically the title, but with spaces replaced with underscores, all lowercase, etc"
    )
    brief_description: str = Field(
        description="A short description shown when entering the room"
    )
    long_description: str = Field(
        description="A detailed description shown when examining the room"
    )
    exit_descriptions: dict[str, str] = Field(
        description="A dictionary of exit descriptions for each direction"
    )


class Room:
    """A location in the game world that characters can occupy."""

    def __init__(self, room_id: str, description: RoomDescription):
        self.id: str = room_id
        self.description: RoomDescription = description
        self.exits: dict[str, "Room"] = {}

    def add_exit(self, direction: str, destination: "Room") -> None:
        """Add an exit from this room to another room."""
        self.exits[direction] = destination

    def remove_exit(self, direction: str) -> None:
        """Remove an exit from this room."""
        self.exits.pop(direction, None)

    def get_exit(self, direction: str) -> "Room | None":
        """Get the room that an exit leads to."""
        return self.exits.get(direction)

    def describe(self) -> str:
        """Get a full description of the room."""
        exit_list = ", ".join(self.exits.keys()) if self.exits else "none"
        return f"{self.description.title}\n\n{self.description.long_description}\n\nExits: {exit_list}"

    def __str__(self) -> str:
        return self.description.title

    def __repr__(self) -> str:
        return f"Room(id='{self.id}', title='{self.description.title}')"


================================================
File: core/world.py
================================================
import asyncio
from collections import defaultdict
from typing import Optional
from dataclasses import dataclass
from pydantic import BaseModel, Field

from .character import Character
from .player import Player
from .room import Room, RoomDescription
from .character_action import CharacterAction

class WorldDescription(BaseModel):
    title: str = Field(
        description="The title of the game world"
    )
    brief_description: str = Field(
        description="A short one pargraph description of the world shown everytime you log in"
    )
    long_description: str = Field(
        description="A detailed description of the world shown when examining it"
    )
    other_details: str = Field(
        description="Other details about the world that are not directly observable by the player"
    )

class World:
    """
    Central game world manager responsible for game state and logic.
    Provides factory methods for world construction and APIs for state modification.
    """

    def __init__(self, description: WorldDescription):
        self.description = description
        self.rooms: dict[str, Room] = {}
        self.characters: dict[str, Character] = {}
        self.room_characters: dict[str, list[Character]] = defaultdict(list)
        self.starting_room_id: Optional[str] = None

    # Factory methods for world construction
    def create_room(self, room_id: str, description: RoomDescription) -> Room:
        """Create and register a new room in the world."""
        if room_id in self.rooms:
            raise ValueError(f"Room with id '{room_id}' already exists")
        
        room = Room(room_id, description)
        self.rooms[room_id] = room
        return room

    def connect_rooms(self, from_id: str, to_id: str, direction: str) -> None:
        """Create a one-way connection between rooms."""
        if from_id not in self.rooms or to_id not in self.rooms:
            raise ValueError("Both rooms must exist")
            
        self.rooms[from_id].add_exit(direction, self.rooms[to_id])

    def set_starting_room(self, room_id: str) -> None:
        """Set the starting room for new players."""
        if room_id not in self.rooms:
            raise ValueError(f"Room '{room_id}' does not exist")
        self.starting_room_id = room_id

    # Character management
    def login_player(self, player_name: str) -> Player:
        """Create and place a new player in the starting room."""
        if not self.starting_room_id:
            raise RuntimeError("No starting room set")
            
        player = Player(player_name, self)
        self.characters[player.id] = player
        self.room_characters[self.starting_room_id].append(player)
        return player

    def logout_player(self, player: Player) -> None:
        """Remove a player from the world."""
        room = self.get_character_room(player.id)
        if room:
            self.room_characters[room.id].remove(player)
        self.characters.pop(player.id)

    def get_character_room(self, character_id: str) -> Room | None:
        """Get the room a character is currently in."""
        character = self.characters[character_id]
        for room_id, characters in self.room_characters.items():
            if character in characters:
                return self.rooms[room_id]
        return None

    def move_character(self, character_id: str, direction: str) -> Room | None:
        """Move a character in a direction if possible."""
        character = self.characters[character_id]
        current_room = self.get_character_room(character_id)
        if not current_room:
            return None
            
        target_room = current_room.get_exit(direction)
        if not target_room:
            return None
            
        self.room_characters[current_room.id].remove(character)
        self.room_characters[target_room.id].append(character)
        return target_room

    # Game loop and action processing
    async def tick(self) -> None:
        """Process one game tick for all characters."""
        await asyncio.gather(
            *(character.tick() for character in self.characters.values())
        )

    async def process_character_action(
        self, character: Character, action: CharacterAction
    ) -> None:
        """Process a character's action."""
        if action.action_type == "move":
            room = self.move_character(character.id, action.direction)
            if room is None:
                await character.send_message("error", "You can't go that way.")
            else:
                await character.send_message("room", room.describe())
        elif action.action_type == "look":
            room = self.get_character_room(character.id)
            if room:
                await character.send_message("room", room.describe())

    def create_npc(self, npc_id: str, name: str, room_id: str, attributes: dict[str, any] = {}) -> Character:
        """Create and register a new NPC in the world."""
        if npc_id in self.characters:
            raise ValueError(f"Character with id '{npc_id}' already exists")
        
        # Note: You'll need to create an NPC class that inherits from Character
        npc = NPC(npc_id, name, self, attributes)
        self.characters[npc_id] = npc
        self.room_characters[room_id].append(npc)
        return npc


================================================
File: gen/__init__.py
================================================
from .world_gen import generate_world
from .room_gen import generate_room, generate_starting_room
from .create_world import create_world

__all__ = ['generate_world', 'generate_room', 'generate_starting_room', 'create_world'] 

================================================
File: gen/create_world.py
================================================
import json
from .world_gen import generate_world
from .room_gen import generate_starting_room
from devtools import debug

async def create_world(theme: str) -> None:
    """Create a new world with the specified theme."""
    world_desc = await generate_world(theme)
    print("\nGenerated World:")
    debug(world_desc)
    
    room_desc = await generate_starting_room(world_desc)
    print("\nGenerated Room:")
    debug(room_desc)

================================================
File: gen/room_gen.py
================================================
from pydantic import BaseModel
from pydantic_ai import Agent
from pydantic_ai.models.openai import OpenAIModel

from ..config import creative_model, OPENROUTER_BASE_URL, OPENROUTER_API_KEY
from ..core.room import RoomDescription
from ..core.world import WorldDescription

prompt = """
You are a master environment designer for an immersive text adventure. Create a captivating room that players will remember exploring.

Given the world description and theme, design a room with:

1. An evocative, specific title that suggests its function or atmosphere
2. A striking first impression (2-3 sentences) that immediately establishes mood and key visual elements
3. A layered, detailed description that:
   - Engages multiple senses (what players see, hear, smell, feel)
   - Uses concrete, specific details rather than generalizations
   - Emphasizes one dominant mood or emotion
   - Places 3-4 interactive elements that invite player investigation
   - Suggests how this space is/was used by inhabitants
   - Includes subtle environmental storytelling elements

The room should:
- Feel like an organic extension of the established world
- Balance aesthetic description with functional gameplay elements
- Include at least one unexpected or surprising feature
- Contain subtle clues about the broader world/story
- Suggest possible interactions beyond simple observation
- Have its own micro-history within the larger setting

Technical considerations:
- Clear indication of exits/connections to other areas
- At least one distinctive object that could be examined further
- Variation in scale and composition (high/low elements, light/shadow)
- Environmental factors that might affect gameplay (sounds that mask movement, scents that reveal hidden aspects)

Avoid:
- Generic descriptors like "beautiful," "amazing," or "interesting"
- Static descriptions that feel like empty stage sets
- Listing features without integrating them into the space
- Describing everything with equal emphasis

Write as if you're crafting a space that will intrigue players and make them think: "I wonder what would happen if I..."
"""

model = OpenAIModel(
    creative_model,
    base_url=OPENROUTER_BASE_URL,
    api_key=OPENROUTER_API_KEY,
)

room_gen_agent = Agent(
    model=model,
    result_type=RoomDescription,
    retries=2,
    system_prompt=prompt,
    model_settings={
        "temperature": 0.7,
    },
)

async def generate_starting_room(world: WorldDescription) -> RoomDescription:
    """Generate a room description that fits within the given world.
    
    Args:
        world: The WorldDescription containing context about the game world
        
    Returns:
        RoomDescription containing the generated room details
    """
    
    user_prompt = f"""
    This is the starting room for the owrld.
    When a user first logs in to this world, they will be in this room.
    This room should be a good representation of the world and its theme.

    Generate a new room description that fits in this world.
    World Title: {world.title}
    World Description: {world.long_description}
    Other World Details: {world.other_details}
    """
        
    result = await room_gen_agent.run(
        user_prompt,
    )
    return result.data


async def generate_room(world: WorldDescription) -> RoomDescription:
    """Generate a room description that fits within the given world.
    
    Args:
        world: The WorldDescription containing context about the game world
        
    Returns:
        RoomDescription containing the generated room details
    """
    
    user_prompt = f"""
    Generate a new room description that fits in this world.
    World Title: {world.title}
    World Description: {world.long_description}
    """
        
    result = await room_gen_agent.run(
        user_prompt,
    )
    return result.data 

================================================
File: gen/world_gen.py
================================================
from pydantic import BaseModel, Field
from pydantic_ai import Agent, RunContext
from pydantic_ai.models.openai import OpenAIModel

from ..config import creative_model, OPENROUTER_BASE_URL, OPENROUTER_API_KEY
from ..core.world import WorldDescription

prompt = """
You are a master worldbuilder for an interactive text adventure.

Create an immersive game world with:
1. An evocative title that captures the essence of the setting
2. A captivating hook (2-3 sentences) that immediately draws players in
3. A rich, detailed description that:
   - Engages all senses (sights, sounds, smells, textures)
   - Uses vivid, specific language and strong action verbs
   - Varies sentence structure for rhythmic flow
   - Incorporates mysterious elements that invite exploration
   - Hints at hidden dangers and treasures
   - Suggests a living world with hints of its history

The world should:
- Center on the user's theme
- Balance whimsy with a sense of wonder and light danger
- Feature at least one unusual characteristic that makes this world unique
- Leave open questions that spark curiosity

Avoid:
- Generic fantasy tropes without fresh twists
- Overly formal or academic language
- Information dumps without storytelling
- Telling rather than showing


Most of these fields will be immediately observable by the player, with the exception of other_details.

other_details can contain information about the world that will not be immediately observable by the player:
- history
- secrets
- locations that may be discovered later in the game
- potential character types who might inhabit this world

"""

model = OpenAIModel(
    creative_model,
    base_url=OPENROUTER_BASE_URL,
    api_key=OPENROUTER_API_KEY,
)

world_gen_agent = Agent(
    model=model,
    result_type=WorldDescription,
    retries=2,
    system_prompt=prompt,
    model_settings={
        "temperature": 0.7, 
    },
)

async def generate_world(theme: str) -> WorldDescription:
    """Generate a world description, optionally based on a theme.
    
    Args:
        theme: Optional theme to influence the world generation
        
    Returns:
        WorldDescription containing the generated world details
    """
    user_prompt = f"Generate a new world description with the theme: {theme}"
        
    result = await world_gen_agent.run(user_prompt)
    return result.data 

================================================
File: networking/client.py
================================================
import asyncio
import websockets
import sys
from websockets.client import WebSocketClientProtocol


async def handle_input(websocket: WebSocketClientProtocol) -> None:
    """Read input from console and send to server."""
    while True:
        try:
            message = await asyncio.get_event_loop().run_in_executor(None, input)
            await websocket.send(message)
        except (EOFError, KeyboardInterrupt):
            break


async def handle_messages(websocket: WebSocketClientProtocol) -> None:
    """Receive and print messages from the server."""
    try:
        async for message in websocket:
            print(message)
    except websockets.exceptions.ConnectionClosed:
        pass


async def main(uri: str = "ws://localhost:8765") -> None:
    """Connect to the MUD server and handle I/O."""
    try:
        async with websockets.connect(uri) as websocket:
            input_task = asyncio.create_task(handle_input(websocket))
            message_task = asyncio.create_task(handle_messages(websocket))

            # Wait for either task to complete
            done, pending = await asyncio.wait(
                [input_task, message_task], return_when=asyncio.FIRST_COMPLETED
            )

            # Cancel remaining tasks
            for task in pending:
                task.cancel()
                try:
                    await task
                except asyncio.CancelledError:
                    pass
    except websockets.exceptions.ConnectionClosed:
        print("\nDisconnected from server")
    except KeyboardInterrupt:
        print("\nGoodbye!")
    except Exception as e:
        print(f"\nError: {e}")
    finally:
        sys.exit(0)


if __name__ == "__main__":
    asyncio.run(main())


================================================
File: networking/messages.py
================================================
from enum import Enum
from pydantic import BaseModel, Field
from typing import Literal

# ANSI color codes
BLUE = "\033[94m"
GREEN = "\033[92m"
RED = "\033[91m"
RESET = "\033[0m"

MessageToPlayerType = Literal["server", "room", "error"]


class MessageToPlayer(BaseModel):
    """
    A message to the player. Typically for display purposes.
    """

    msg_type: MessageToPlayerType
    message: str
    msg_src: str | None = Field(
        description="The player or character who sent the message, otherwise None.",
        default=None,
    )

    def __str__(self) -> str:
        color = {"server": BLUE, "room": GREEN, "error": RED}[self.msg_type]

        src = f" {self.msg_src}" if self.msg_src else ""
        return f"{color}[{self.msg_type}]{src}{RESET}: {self.message}\n"


================================================
File: networking/server.py
================================================
import asyncio
import websockets
from websockets import ClientConnection, serve
from pathlib import Path

from ..core.player import Player
from ..core.world import World
from ..core.command_parser import parse
from ..persist import load_world


class Server:
    def __init__(self, world: World):
        self.clients: list[tuple[Player, ClientConnection]] = []
        self.world = world

    @classmethod
    async def create(cls, world_file: str | Path) -> "Server":
        """Factory method to create a server with a loaded world."""
        world = load_world(world_file)
        return cls(world)

    async def login_user(self, websocket: ClientConnection) -> Player:
        """Login a user and add them to the world."""
        await websocket.send("Welcome to the game!")
        await websocket.send("What is your name?")
        name = (await websocket.recv()).strip()
        return self.world.login_player(name)

    async def handle_client(self, websocket: ClientConnection) -> None:
        """Handle a single client connection."""
        player = await self.login_user(websocket)
        self.clients.append((player, websocket))

        try:
            await self.broadcast(f"{player.name} joined the server")
            await asyncio.gather(
                self._handle_client_input(player, websocket),
                self._handle_client_output(player, websocket),
            )
        except Exception as e:
            print(f"Error handling client {player.name}: {e}")
        finally:
            self.world.logout_player(player)
            self.clients = [(p, c) for p, c in self.clients if c != websocket]
            await self.broadcast(f"{player.name} left the server")

    async def _handle_client_input(self, player: Player, websocket: ClientConnection) -> None:
        """Handle incoming messages from a client."""
        try:
            async for message in websocket:
                await player.process_command(message)
        except websockets.exceptions.ConnectionClosed:
            pass

    async def _handle_client_output(self, player: Player, websocket: ClientConnection) -> None:
        """Handle outgoing messages to a client."""
        try:
            async for message in player:
                await websocket.send(str(message))
        except websockets.exceptions.ConnectionClosed:
            pass

    async def broadcast(self, message: str) -> None:
        """Send a text message to all connected clients."""
        for player, _ in self.clients:
            try:
                await player.send_message("server", message)
            except websockets.exceptions.ConnectionClosed:
                pass

    async def run_world_ticker(self) -> None:
        """Run the world simulation ticker."""
        while True:
            await self.world.tick()
            await asyncio.sleep(1)

    async def start(self, host: str = "localhost", port: int = 8765) -> None:
        """Start the server and world simulation."""
        async with serve(self.handle_client, host, port) as server:
            print(f"Server started on ws://{host}:{port}")
            
            try:
                await asyncio.gather(
                    server.serve_forever(),
                    self.run_world_ticker()
                )
            except asyncio.CancelledError:
                print("Server shutdown initiated...")


async def main() -> None:
    server = await Server.create("world1.json")
    await server.start()


if __name__ == "__main__":
    asyncio.run(main())


